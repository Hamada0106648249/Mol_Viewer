<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NGL Minimal Trajectory Player (Component.setFrame fix)</title>
<script src="https://unpkg.com/ngl@0.10.4/dist/ngl.js"></script>
<style>
  body{margin:0;background:#0b1021;color:#e8ebff;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial}
  .bar{display:flex;gap:10px;align-items:center;padding:10px;background:#12172b;border-bottom:1px solid rgba(255,255,255,.12)}
  .bar input,.bar button{background:rgba(255,255,255,.08);color:#e8ebff;border:1px solid rgba(255,255,255,.2);border-radius:8px;padding:6px 10px}
  #stage{position:fixed;inset:50px 0 0 0}
  #log{position:fixed;left:10px;top:50px;width:460px;max-height:40vh;overflow:auto;background:rgba(0,0,0,.5);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.15)}
  .row{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<div class="bar">
  <button id="open">Open Fileâ€¦</button>
  <input id="file" type="file" accept=".pdb,.cif,.mmcif,.mmtf,.gro,.ent" style="display:none" />
  <div class="row">
    <label>Frame <input id="frame" type="range" min="0" max="0" value="0"></label>
    <span id="fi">0/0</span>
  </div>
  <button id="playNative">Play (native)</button>
  <button id="playComp">Play (component)</button>
  <button id="playFallback">Play (fallback)</button>
  <button id="pause">Pause</button>
  <span id="status" style="margin-left:10px;opacity:.85"></span>
</div>
<div id="stage"></div>
<div id="log"></div>

<script>
(function(){
  const log = document.getElementById('log');
  const L = (...a)=>{const s=a.map(x=>typeof x==='string'?x:JSON.stringify(x)).join(' '); log.innerHTML = '<div>'+s+'</div>'+log.innerHTML; console.log(...a);};

  const stage = new NGL.Stage('stage', { backgroundColor:'#0b1021' });
  window.addEventListener('resize', ()=>stage.handleResize());

  const openBtn = document.getElementById('open');
  const fileInp = document.getElementById('file');
  const frame = document.getElementById('frame');
  const fi = document.getElementById('fi');
  const status = document.getElementById('status');
  const playNativeBtn = document.getElementById('playNative');
  const playCompBtn = document.getElementById('playComp');
  const playFallbackBtn = document.getElementById('playFallback');
  const pauseBtn = document.getElementById('pause');

  let comp=null, rep=null, traj=null, nFrames=0, cur=0, playing=false, timer=null;

  const setStatus = t => status.textContent = t;
  const msPerFrame = ()=>80; // adjust as desired
  function detectFrames(){
    if (traj && Number.isFinite(traj.frameCount)) return traj.frameCount|0;
    try{ if (comp && comp.maxFrame != null) return (comp.maxFrame|0)+1; }catch(_){}
    try{ const f = comp?.structure?.frames; if (Array.isArray(f)) return f.length|0; }catch(_){}
    return 1;
  }

  function showFrame(i){
    if (!comp) return;
    nFrames = detectFrames(); if (nFrames<1) nFrames = 1;
    cur = ((i%nFrames)+nFrames)%nFrames;
    const model1 = cur + 1;

    let path = 'none';
    if (traj && typeof traj.setFrame === 'function') {
      try { traj.setFrame(cur); path = 'native: traj.setFrame'; }
      catch(e){ path = 'nativeFailed'; }
    }
    // NEW: if no traj, drive the component frames directly
    if (path === 'none' || path === 'nativeFailed') {
      if (comp && typeof comp.setFrame === 'function') {
        try { comp.setFrame(cur); path = 'component.setFrame'; }
        catch(e){ path = 'componentFailed'; }
      }
    }
    // Last-resort selection per model
    if (path === 'componentFailed' || path === 'none' || path === 'nativeFailed') {
      try {
        if (!rep) rep = comp.addRepresentation('cartoon', { colorScheme:'chainname' });
        rep.setParameters({ sele: `model ${model1}` });
        path = 'fallback: sele "model N"';
      } catch(e){ L('Fallback error:', e.message||e); }
    }

    try { comp.updateRepresentations({ what:{ position:true } }); } catch(_){}
    try { stage.viewer.requestRender(); } catch(_){}
    frame.value = cur; fi.textContent = `${cur}/${Math.max(0, nFrames-1)}`;
    setStatus(`Frame ${cur} via ${path}`);
  }

  function bindSignals(){
    if (!traj || !traj.signals || !traj.signals.frameChanged) return;
    try {
      traj.signals.frameChanged.add(()=>{
        try { comp.updateRepresentations({ what:{ position:true } }); stage.viewer.requestRender(); } catch(_){}
      });
    }catch(_){}
  }

  async function loadSource(src, nameHint){
    try{
      if (comp) stage.removeComponent(comp);
      comp=rep=traj=null; nFrames=cur=0; stopManual();

      const name = nameHint || (src && src.name) || '';
      setStatus('Loading: ' + (name||'file')); L('Loading with asTrajectory:true', name);
      try { comp = await stage.loadFile(src, { asTrajectory:true }); }
      catch(e1){ L('Retry without asTrajectory:', e1.message||e1); comp = await stage.loadFile(src, {}); }

      rep = comp.addRepresentation('cartoon', { colorScheme:'chainname' });
      comp.autoView();

      const list = comp.trajectoryList || [];
      traj = list.length ? list[0] : null;
      L(traj ? `Trajectory detected: frames=${traj.frameCount}` : 'No traj; will use component.setFrame / selection');

      nFrames = detectFrames();
      frame.max = Math.max(0, nFrames-1); frame.value = 0; fi.textContent = `0/${Math.max(0,nFrames-1)}`;

      bindSignals();
      showFrame(0);
      setStatus(nFrames>1 ? `Ready: ${nFrames} frames` : 'Single-frame structure');
    }catch(e){
      L('Load error:', e.message||e); alert('Load failed: '+(e.message||e));
    }
  }

  function stopManual(){ playing=false; if (timer){ clearTimeout(timer); timer=null; } }
  function play(loopFn,label){
    if (playing || nFrames<=1) return;
    playing = true; setStatus(`Playing (${label})`);
    (function step(){ if (!playing) return; showFrame((cur+1)%nFrames); timer = setTimeout(step, msPerFrame()); })();
  }
  function pauseAll(){ try{ if (traj && traj.player && traj.player.pause) traj.player.pause(); }catch(_){}
    stopManual(); setStatus('Paused'); }

  // UI
  openBtn.addEventListener('click', ()=>fileInp.click());
  fileInp.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if (!f){ setStatus('No file selected'); return; }
    L('File selected:', f.name, f.size+' bytes');
    loadSource(f, f.name);
    e.target.value = '';
  });
  frame.addEventListener('input', ()=> showFrame(+frame.value));
  playNativeBtn.addEventListener('click', ()=>{
    if (!nFrames||nFrames===1){ setStatus('No trajectory detected'); return; }
    // prefer traj.player if available; otherwise fall back to component loop
    if (traj && traj.player && typeof traj.player.play==='function'){
      try { traj.player.timeout = msPerFrame(); traj.player.play(); setStatus('Playing (traj.player)'); return; } catch(_){}
    }
    play(showFrame,'component/traj-independent');
  });
  playCompBtn.addEventListener('click', ()=>{
    if (!nFrames||nFrames===1){ setStatus('No trajectory detected'); return; }
    play(showFrame,'component.setFrame');
  });
  playFallbackBtn.addEventListener('click', ()=>{
    if (!nFrames||nFrames===1){ setStatus('No trajectory detected'); return; }
    play(showFrame,'fallback selection');
  });
  pauseBtn.addEventListener('click', pauseAll);
})();
</script>
</body>
</html>
